<!DOCTYPE html>
<meta charset="utf-8">

<head>

	<title> Dose-Volume Histogram Editor </title>

	<!-- Bootstrap css --> 
	<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet" />

	<style>
		/* D3 stuff */

		.axis line, .axis path {
			fill: none;
			/*stroke: black;*/
			shape-rendering: crispEdges;
		}

		.axis text {
			font-family: sans-serif;
			font-size: 11px;
		}

		.tick line {
    		opacity: 0.2;
    		stroke: black;
  		}

  		.crosshair {
  			stroke: dodgerblue;
  			fill: none;
  			stroke-width: 1;
  		}
  		.increasing {
  			stroke: #CD5C5C;
  			fill: none;
  			stroke-width: 1;
  		}

  		.btn {
  			color: #fff;
  		}

  		circle {
  			cursor: move;
  			stroke: steelblue;
  			fill: none;
  			stroke-width: 2px;
  		}
  		.selected {
  			opacity: .5;
  		}

  		/*.hist-line path, .hist-line line {
			fill: none;
			stroke: steelblue;
			stroke-width: 4px;
			shape-rendering: crispEdges;
		}*/

		/* HTML stuff */

		#histogram-area {
			height: 520px;
			background: steelblue;
			padding: 10px;
		}
		#histogram-list-title {
			color: steelblue;
			background: white;
			margin-left: 20px;
			text-align: center;
			width: 180px;
			height: 39px;
			font-size: 18px;
			padding: 6px;
			border: 1px solid white;
		}

		#new-histogram {
			/*width: 100%;*/
			background: steelblue;
			border: 1px solid #fff;
			border-radius: 0;
			font-size: 18px;
			width: 180px;
			margin-left: -15px;
		}
		#new-histogram:hover {
			background: white;
			color: steelblue;
		}
		#save {
			display: none;
			border-radius: 100%;
			background: steelblue;
			border: 1px solid #fff;
			position: absolute;
			bottom: 0;
			right: 0;
			margin-bottom: 25px;
			margin-right: 25px;
		}
		#save:hover {
			background: white;
			color: steelblue;
		}
		#save-container {
			position: absolute;
			bottom: 0;
			right: 0;
		}

		#left, #right {
			margin-top: 10px;
			height: 450px;
		}
		#left {
			border-right: 1px solid #fff;
		}

		button:focus {
			outline: 0;
		}
		textarea:focus, input:focus {
		    outline: 0;
		}
		.histogram-name {
			border: 0;
			background: steelblue;
			border-bottom: 1px solid #fff;
			width: 90%;
			color: #333;
			font-size: 20px;
		}

		.dose {
			width: 40%;
			float: left;
			border: 0;
			text-align: center;
			border-right: 2px solid #CD5C5C;
		}
		.volume {
			width: 40%;
			border: 0;
			text-align: center;
			border-left: 2px solid #CD5C5C;
		}
		.points {
			margin-top: 10px;
			margin-left: 15px;
			margin-bottom: 10px;
		}
		.point {
			margin-top: 5px;
			/*cursor: move;*/
		}

		#add-point {
			border: 1px solid #fff;
			color: #fff;
			background: steelblue;
			width: 90%;
			border-radius: 0;
			font-size: 13px;
		}
		#add-point:hover {
			background: white;
			color: steelblue;
		}

		.histogram-list-item {
			margin-left: 5px;
		    width: 100%;
		    height: 30px;
		    border-radius: 0;
		    border: 0;
		    margin-bottom: 10px;
		}
		.histogram-item-name {
			float: left;
			color: #333;
		}

		/* Num points style #1 */
		.num-points1 {
			color: steelblue;
		    border-radius: 100%;
		    border: 2px solid steelblue;
		    width: 17%;
		    float: right;
		    margin-top: -3px;
		}
		/* Num points style #2 */
		.num-points2 {
		    color: #fff;
		    border-radius: 100%;
		    width: 20%;
		    float: right;
		    margin-top: -1px;
		    background: #CD5C5C;
		}
		/* Num points style #3 */
		.num-points {
		    color: #fff;
		    width: 17%;
		    float: right;
		    height: 30px;
		    padding-top: 5px;
		    margin-top: -6px;
		    margin-right: -12px;
		    background: #CD5C5C;
		}

	</style>

</head>

<body>
  <div class="container">

    <!-- Title --> 
    <div class="row">
      <div class="col-lg-9">
        <h2>Dose-Volume Histogram Editor</h2> 
      </div>
    </div>

    <div class="row">
    	<div class="col-lg-8">
    		<!-- Where the chart will be rendered --> 
    		<div id="svg-area"></div>
    	</div>

    	<div class="col-lg-4" id="histogram-area">

    		<div class="row">

    			<!-- All histograms header --> 
    			<div class="col-md-6" id="histogram-list-title"> All histograms </div>

    			<!-- To create a histogram --> 
    			<div class="col-md-6">
	    			<button type="button" class="btn btn-primary" id="new-histogram">New histogram</button>
	    		</div>
	    	</div>

    		<div class="row">
    			<!-- The list of histogram names --> 
    			<div class="col-md-6" id="left">
    				<ul class="list-group" id="histogram-list"></ul>
    			</div>
    				
    			<!-- Where the input form will be injected --> 
    			<div class="col-md-6" id="right">
    				<div id="histogram-input"></div>
    			</div>
    		</div>

    		<!-- The save button -->
    		<div class="row">
    			<div class="col-md-1"></div>
    			<div class="col-md-10" id="save-container">
	    			<button type="button" class="btn btn-success" id="save">
	    				<span class="glyphicon glyphicon-ok" aria-hidden="true"></span>
	    			</button>
	    		</div>
    			<div class="col-md-1"></div>
    		</div>

    	</div>

    </div>

    <div class="row">
    	
    </div>

  </div>
</body>

<!-- D3.js --> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<!-- JQuery --> 
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- JQuery UI --> 
<script src="http://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>


<script type="text/javascript">

	/* D3 functions and set-up */

	// Set margins
  	var margin = {top: 20, right: 30, bottom: 30, left: 40},
      	width = 770 - margin.left - margin.right,
      	height = 800 - margin.top - margin.bottom;

    // Boundaries
    var xmax = 8000, ymax = 1; 				// in whatever units we're using  
    var xmax_px = 700, ymax_px = 500;		// in pixels 

	// Start the x-scale with an input domain of 0-8000
	var xscale = d3.scale.linear().domain([0, xmax]).range([0, xmax_px]);
	var xscale_inverse = d3.scale.linear().domain([0, xmax_px]).range([0, xmax]);

	// y-axis corresponds to %, so 0-1.0
	var yscale = d3.scale.linear().domain([ymax, 0]).range([0, ymax_px]);
	var yscale_inverse = d3.scale.linear().domain([0, ymax_px]).range([ymax, 0]);

	// Create the x-axis 
	var xaxis = d3.svg.axis()
		.scale(xscale)
		.innerTickSize(-height)
    	.outerTickSize(0)
    	.tickPadding(10)
		.orient("bottom");

	// Create the y-axis
	var yaxis = d3.svg.axis()
		.scale(yscale)
		.innerTickSize(-width)
	    .outerTickSize(0)
	    .tickPadding(10)
		.orient("left");

	// The grid
	var grid = d3.svg.line()
    	.x(function (d) { return xscale(d.x); })
    	.y(function (d) { return yscale(d.y); });

    // Functions to draw the crosshair lines to indicate where the cursor is 
	var lx = d3.svg.line().x(function (d) { return d.x; }).y(function (d) { return d.y; });
	var ly = d3.svg.line().x(function (d) { return d.x; }).y(function (d) { return d.y; });

	// Line connecting the points of the current histogram
	//var hist_line = d3.svg.line();

	// All of the histogram lines 
	var hist_lines = [];


	/* Rendering the SVG */

	// The svg area where the histogram is appended
  	var svg = d3.select("#svg-area").append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
		.append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	// Render the axes
	svg.append("g")
		.attr("class", "axis")
		.call(yaxis);
	svg.append("g")
		.attr("class", "axis")
		.attr("transform", "translate(0," + (height - 250) + ")")
		.call(xaxis);

	// Will contain the coordinates when client moves cursor 
	var tooltip = svg.append("text")
		.attr("text-anchor", "middle")
		.attr("font-family", "sans-serif")
		.attr("font-size", "11px")
		.attr("fill", "#333");

	// The crosshair lines 
	var chx = svg.append("path")
		.attr("d", lx([]))
		.attr("class", "crosshair");
	var chy = svg.append("path")
		.attr("d", ly([]))
		.attr("class", "crosshair");

	// All of the svg histogram paths
	var svg_paths = [];

	// Set interactive functionality   
	d3.select(window).on('mousemove', mousemove) 	// Display coordinates
					 .on('mousedown', click)		// Put down a point 
					 .on('mouseup', mouseup);		// Release any points being dragged



	/* Functions */

	// Keeps track of if we're creating/editing a histogram
	var editing = false;
	var reediting = false;

	// Keeps track of if a point is legal
	var legal = true;

	// Keeps track of points 
	var selected;		// being selected
	var dragged;		// being dragged 

	// Keeps track of histogram being edited
	var histogram;

	// Keeps track of the data of all the histograms the user has created 
	var histograms = {};

	// Keeps track of the ui histogram data 
	var histogramsUI = {};

	/* Draw the current histogram */
	function draw () {
		// Draw the line between the points -- for some reason css wasn't working so did styling here 
		svg_paths[svg_paths.length - 1].datum(histograms[histogram])
			.attr("d", hist_lines[hist_lines.length - 1])
			.attr("fill", "none")
			.attr("stroke", "steelblue")
			.attr("stroke-width", 2);

		// TODO: can sort by id to make sure points are in correct order 
		// (if change things in form view)

		// Join new points with old ones  
		var circle = svg.selectAll("circle").data(histograms[histogram], function (d) { return d; });

		// Update with new points 
		circle.enter().append("circle").attr("r", 1e-6);

		// Apply these attributes to new and old points
		circle.attr("cx", function (d) { return d[0]; })
			.attr("cy", function (d) { return d[1]; })
			.attr("id", function (d, i) { return d[2]; })
			.on("mousedown", function (d) { 
				// This node is being both selected and dragged
				selected = dragged = d;
			})
			.transition()
			.duration(1000)
			.ease("elastic")
			.attr("r", 4);

		// What to do when the point is selected
		circle.classed("selected", function (d) { return d === selected; })
			.attr("cx", function (d) { return d[0]; })
			.attr("cy", function (d) { return d[1]; });

		// Remove any no-longer existing elements 
		circle.exit().remove();

		if (d3.event) {
			d3.event.preventDefault();
			d3.event.stopPropagation();
		}
		
	}

	/* Get the x,y relative and absolute positions of mouse event */
	function position () {
		// Get the coordinates and map them 
		var coords = d3.mouse(svg.node());
		var x = xscale_inverse(coords[0]);
		var y = yscale_inverse(coords[1]);
		
		// Round to nearest... ? 
		x = Math.round(x);
		y = Math.round(y * 1000) / 1000.0;

		// If we're beyond the bounds round to nearest boundary
		var outx = true; var outy = true;
		if (x > xmax) {
			x = xmax;
			coords[0] = xmax_px;
		}
		else if (x < 0) {
			x = 0;
			coords[0] = 0;
		}
		else outx = false;
		if (y > ymax) {
			y = ymax;
			coords[1] = 0;
		}
		else if (y < 0) {
			y = 0;
			coords[1] = ymax_px;
		}
		else outy = false;

		return {x: coords[0], y: coords[1], xrel: x, yrel: y, out: outx || outy};
	}

	/* 
		Determines if the point doesn't violate monotonicity/function constraints.
		Must always be montonically decreasing, and the curve must always be a 
		function (any x must yield exactly one y). p1 is the point being added 
		and p2 is the previous point. 
	*/
	function isMonotonicFunction (p1, p2) { return p1[1] > p2[1] && p1[0] > p2[0]; }

	/* Function to set down a point when the client clicks */
	function click () { 
		if (!editing) return;

		// If we're currently dragging a point don't add a new one
		if (dragged) return;

		// Get mouse position
		var pos = position();

		// Don't put down points outside of boundaries 
		if (pos.out) return;	

		// Also don't put point down that violates constraints
		var pi = histograms[histogram].length - 1;
		var prev = histograms[histogram][pi];
		if (prev && !isMonotonicFunction([pos.x, pos.y], prev)) return;
		
		// Add a point to list and to input form 
		var pid = 'point' + histograms[histogram].length;
		var point = d3.mouse(svg.node());
		point.push(pid);
		histograms[histogram].push(point);

		// Add point to the input form by simulating a click
		$("#add-point").trigger('click', {dose: pos.xrel, volume: pos.yrel, pid: pid});

		// Draw everything
		draw();
	}

	/* Function to move a point as well as display the x,y coordinates */
	function mousemove () {
		if (!editing) return;

		// Get mouse position 
		var pos = position();

		// Show tooltip containing coordinates 
		tooltip.attr("x", pos.x - 10).attr("y", pos.y - 10).text(pos.xrel + ', ' + pos.yrel);

		// Show the crosshair lines 
		chx.attr("d", lx([{x: pos.x, y: pos.y}, {x: pos.x, y: 500}]));
		chy.attr("d", ly([{x: pos.x, y: pos.y}, {x: 0, y: pos.y}]));


		// If we're not dragging, toggle crosshair colors depending on constraints 
		if (!dragged) {
			// If we're violating constraints, show crosshair as red 
			var pi = histograms[histogram].length - 1;
			var prev = histograms[histogram][pi];
			if (prev && !isMonotonicFunction([pos.x, pos.y], prev)) {
				chx.classed('increasing', true);
				chy.classed('increasing', true);

				chx.classed('crosshair', false);
				chy.classed('crosshair', false);
			}
			else {
				chx.classed('increasing', false);
				chy.classed('increasing', false);

				chx.classed('crosshair', true);
				chy.classed('crosshair', true);
			}
		}

		// Otherwise drag a point around
		else {
			// Where the point is being dragged 
			var dragged_x = Math.max(0, Math.min(xmax_px, pos.x));
			var dragged_y = Math.max(0, Math.min(ymax_px, pos.y));
			var pos = [dragged_x, dragged_y];	

			// Figure out if draggable or not, based on constraints
			var draggable = true;

			// Get the index of the selected point
			var points = histograms[histogram];
			var point = $("circle.selected").first().attr("id");
			if (point) {
				var index = parseInt(point.replace('point', ''));

				// Boundary case #1: first point (look at constraints relative to second point)
				if (index === 0) {
					if (points.length > 1) draggable = isMonotonicFunction(points[1], pos);
				}
				// Boundary case #2: last point 
				else if (index === points.length - 1) {
					draggable = isMonotonicFunction(pos, points[index - 1]);
				}
				// Regular case: Determine constraints in relation to previous and subsequent points 
				else {
					draggable = isMonotonicFunction(pos, points[index - 1]);
					draggable = draggable && isMonotonicFunction(points[index + 1], pos);
				}
			}

			// Only drag to position if doesn't violate constraints
			if (draggable) {
				dragged[0] = dragged_x;
				dragged[1] = dragged_y;
			}

			// Update the form UI
			var form_point = $("div#" + dragged[2]).children();
			$(form_point[0]).val(Math.round(xscale_inverse(dragged[0])));
			$(form_point[1]).val(Math.round(yscale_inverse(dragged[1]) * 1000) / 1000);

			// When dragging always show blue crosshairs 
			chx.classed('increasing', false);
			chy.classed('increasing', false);

			chx.classed('crosshair', true);
			chy.classed('crosshair', true);

			draw();
		}
	}

	/* Release any dragged points */
	function mouseup () { dragged = selected = null; }


	/* Textual histogram info functionality */

	// Creates the input form for the name of the histogram 
	var histogramInput = function (hid) {
		return $('<div class="histogram-info" id="' + hid + '"><input type="text" placeholder="Histogram name" class="histogram-name"><div class="points"></div><button type="button" class="btn btn-default" id="add-point">New point</button></div>');
	};

	// Creates the input form for a point 
	var pointInput = function (x, y, pid) {
		var s = '<div class="point" id=' + pid + '>';
		
		var valType = 'value';
		if (x === 'dose') valType = 'placeholder';
		
		s += '<input type="text" ' + valType + '=' + x +' class="dv dose"><input type="text" ' + valType + '=' + y +' class="dv volume"></div>';

		// TODO: Make the point draggable/sortable
		var domObj = $(s);
		//domObj.draggable();

		return domObj;
	};

	// Creates a list group item for the list of histograms
	var histogramItem = function (name, n) {
		var s = '<button class="btn btn-default histogram-list-item" id=' + name + '>';
		s += '<div class="histogram-item-name">' + name + '</div>'
		s += '<div class="num-points">' + n + '</div></button>';
		return $(s);
	};

	// Add a new histogram 
	$("#new-histogram").click(function () {
		// Can only do one histogram at a time
		if (editing) return;

		// Initialize the histogram
		histogram = 'histogram' + Object.keys(histograms).length;	// the placeholder name 
		histograms[histogram] = []; 

		// Initialize the histogram svg 
		svg_paths.push(svg.append("path").attr("class", "hist-line"));
		hist_lines.push(d3.svg.line().interpolate('cardinal'));

		// Add the histogram input form 
		$("#histogram-input").append(histogramInput(histogram));

		// Show save button 
		$("#save").show();

		editing = true;

		// To add a new point to the input form
		$("#add-point").click(function (event, data) {

			// New point initialized graphically
			if (data) var new_point = pointInput(data.dose, data.volume, data.pid);
			// New point initialized from form 
			else var new_point = pointInput('dose', 'volume', 'point' + histograms[histogram].length);

			$(".points").last().append(new_point);

			// To update the point graphically
			$(".dv").change(function () {
				// Check to see if this point already has a graphical representation
				// (in which case just needs to be updated)
				var update = false;
				var pid = $(this).parent().attr('id');
				if ($("circle#" + pid).length > 0) update = true;

				// Get x and y (dose/volume) coordinates 
				var point = $(this).parent().children();
				var dose = parseFloat(point[0].value);
				var volume = parseFloat(point[1].value);

				// TODO

				// If new point violates constraints, show pale red point
				// on graphic side so user can see why it violates, as well 
				// as pale red lines between point and nearest two points. 

				// In addition, input form point violating the constraint should
				// be highlighted red.  

				// If user fixes constraint, red point should disappear 

				// Do not count this point as part of graph/form
				// remove and redraw w/out this point 

				// Only add a point to the list of points for this histogram
				// if it's a valid number 
				if (!isNaN(dose) && !isNaN(volume)) {

					// And if it's within the boundaries
					if (dose <= xmax && dose >= 0 && volume <= ymax && volume >= 0) {
						
						// Convert to pixel values 
						var x = xscale(dose);
						var y = yscale(volume);

						// If it needs to be updated, update point
						if (update) {
							// This seems like a really sketchy way of doing this...
							var circle = d3.select("#" + pid)[0][0];
							circle.__data__[0] = x;
							circle.__data__[1] = y;
						}
						// Otherwise add a new point 
						else histograms[histogram].push([x, y, pid]);

						// Update graph 
						draw();
					}
				}

			});
		}); 

	});

	// Save the current histogram
	$("#save").click(function () {
		// Get the histogram name 
		var name = $(".histogram-name").last().val();

		if (name.length == 0) {
			alert("Please name your histogram.");
			return;
		} 
		if (name in histogramsUI) {
			if (!reediting) {
				alert("The name already exists.");
				return;	
			}
			
			// If we've been re-editing, destroy the old one
			$("#" + name).remove();
		}

		editing = false;

		// Get all the points 
		var points = $(".points").last().children().map(function (i, p) {
			var dose = parseFloat($($(p).children()[0]).val().trim());
			var volume = parseFloat($($(p).children()[1]).val().trim());
			return {x: dose, y: volume};
		});
		
		// Save the histogram in list of histograms
		histogramsUI[name] = points;

		// Minimize the editing view by adding name and # of points to list 
		$("#histogram-list").append(histogramItem(name, points.length));
		$("#" + histogram).hide();

		// Hide the save button 
		$("#save").hide();

		// Switch back to edit view when click on a histogram 
		$(".histogram-list-item").click(function () {
			var all_hists = $(this).parent().children();

			// Find rank of the selected histogram, and hide other points that may be displayed
			var i = -1;
			for (var j = 0; j < all_hists.length; j++) {
				if ($(all_hists[j]).attr('id') == $(this).attr('id')) {
					i = j;
				}
				else $("#histogram" + j).hide();
			}

			if (i < 0) alert("couldn't select");	// this should never happen, but just in case.. 

			// Now push the selected histogram to the back 
			var a = hist_lines.splice(i);
			var b = svg_paths.splice(i);
			hist_lines.push(a);
			svg_paths.push(b);

			// Display the points 
			$("#histogram" + i).show();
			$("#save").show();

			editing = true;
			reediting = true;
		});

		// TODO: Can place ajax call or something here to save the values 
	});


</script>

</html>

<!-- 
	TO DO 
	- maybe just make the whole path red if violate constraints? instead of not letting them do anything 

	- nicer tooltip (look at plot.ly tooltips)
	- grids within each cell that appear on mouseover? 
	- fix borders, crosshair shouldn't go past chart area 
	- non-white area for histogram info area 
	- double click to switch ends 
	- x and y axes disappear? 
	- for some reason .axis line/path is interfering with .hist-line line/path so didn't use css classes for these. fix this
	- change axes to percentages 
	- add axis labels 
	- clear crosshairs 
	- list of points should be scrollable
	- sortable list: http://devheart.org/articles/jquery-customizable-layout-using-drag-and-drop/
	- spline labels 
	- different colors
	- monotonicity constraints
	- make point selection colored 
	- better selection
	- need to visually indicate correspoding form/svg points 
--> 